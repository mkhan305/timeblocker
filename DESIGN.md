## DESIGN
Project: Timeblocker
Ethan D, Mo K, Andrew Y

At the highest level, we wanted to make a project that would be a productivity website to keep track of your work activity. In particular, we wanted to be able to save your work activity as a permanent record. This is what led us to split the webpage into two major parts, one with the Google Calendar integration to save it and the core timer app to track it.
We decided to use next.js (part of react.js) to create our application because it abstracts many of the difficult parts into simplified packages. Furthermore, there were many useful libraries like Chakra that we used in react.js. To learn about react.js, we watched many youtube videos and searched up documentation online. We spent our first few preliminary days doing this.


We start off with the basic features of the program. We first started off with coding a google calendar API. There is a significant amount of documentation online that we started off with, including several youtube videos and numerous tutorials; however, none of these worked. Instead, we were left on our own to code a google calendar API. First off, the authentication and authorization was extremely difficult. We probably spent at least 30 hours trying to debug authentication errors and using different authentication libraries. We first started off by attempting to code the backend OAuthentication for google manually with little help other than the library ‘gapi.’ However, there proved to be too many errors. Gabe LeBlanc, a different TF, can attest to attempting to help us debug part of the authentication and eventually telling us to use an easier library. We then found an easier library coded online that would authenticate a user, but unfortunately it would not handle refresh tokens. Handling refresh tokens would be a critical part of our application. Moreover, even after we managed to authenticate users, we could not add events consistently using this library, so we were forced to code without large-scale library help. We decided to use the next-authentication library but the authentication was still returning back errors and we spent many hours debugging it to no avail. After another 30 hours spent by several members of our group, we went back to the drawing board and decided to all work together to create the authentication. After spending many hours, we finally authenticated the user using the next-authentication library and managed to be able to create events. At the exact moment when we saw that the google calendar API was working, we were jumping up and down with joy. We finally had a working google calendar API. Here is how our final google calendar API was implemented:


We used the next-auth library to provide authentication with google. Although next-auth is mostly used purely for authentication purposes with no google api functionality, we configured our Oauth 2.0 screen to ask for google calendar permissions. This way, we can receive JWT tokens under scopes that allow us to edit calendars and events on behalf of the user. Using the `jwt` callback, we stored the access token and refresh tokens in the token object. This triggers the `session` event, and in the `session` event we again store these tokens in the users session. This allowed us to use the react hooks `getSession` and `getServerSession` to determine whether the user was logged in (to allow or disallow the main functionalities) and use these tokens to actually call methods to create events from the google calendar api. Our actual authentication (the signIn() and signOut() functions) are handled by next-auth specified endpoints in `api/auth/[...nextauth]/route.tsx`.


The code that actually contains the logic to upload an event to the users Google Calendar is in the file `api/createEvent/route.tsx`, which we will explain briefly below. `/createEvent` is meant to be called as a POST request with completedTasks and startTime in the request body. After processing the body of the message, we find the amount of time taken to complete each task by subtracting the completion time of the previous task from the completion time of the current task. With the helper function `getMinutes`, we express this nicely as an integer number of minutes. We also join together all the task names for the title of the event, and if no tasks were completed, we instead get the date in MM/DD/YYYY format to place in the event description. 


The timers were also nontrivial. We started off by coding the timers using an old finance template. After we had coded all three timers (the stopwatch, timer, and pomodoro) and learned javascript documentation, we realized that this code would not work with react.js. Well, that’s an important lesson for next time: make sure your languages are compatible! For context, our code was not structured as a React component. React apps use JSX and component-based architecture. Our timer code at the time didn’t have component-based architecture. We also had direct DOM manipulation (using the function document.querySelector) which is not auspicious in React.js. Instead, React uses state changes to handle the changes in the user interface. React also doesn’t use event listeners directly to elements but instead uses a built-in event handling system. For this reason, we had to completely adapt and change the architecture of our code. When re-evaluating how we wanted to code our timer, we found several tutorials online on how to code the basic stopwatch. Our goal was to start by coding each of the timers separately, and then combine them together in a window with some buttons that can change between the timers. The first tutorial that we found was https://upmostly.com/tutorials/build-a-react-timer-component-using-hooks#:~:text=URL%3A%20https%3A%2F%2Fupmostly.com%2Ftutorials%2Fbuild/. However, this website did not actually have the functionality that we wanted. Thus, we did some research into state management and creating variables. Here is how the code works (the comments also help explain it). 


We used the timer to keep track of elapsed time and the interval to store the id. When one clicks start time, the timer is incremented in intervals of one second. SetInterval, a Javascript function that repeatedly calls a function, is used to increment the timer at intervals. When setInterval is called, it returns a unique id. This id can be used to stop SetInterval from repeatedly calling the function, which stops the timer from counting time. This will allow us to start and stop the timer whenever without worrying about keeping track of or removing time. To resume the time, we just need to resume the interval again. Clearing the time will clear the interval and set the time to 0.


The time is formatted in hours, minutes, and seconds, so we set up recording the time. I would record the total time in seconds but display it as hours, minutes, and seconds. We padded it so that the time formatting looks nice. Padding means adding 0s (once converting the time to a string) if we have too little the amount of numbers so a 00:8_:__   goes to 00:80:00. The math.floor rounds the number to the nearest whole digit.
When coding this, we decided to add a state to counting, not counting, and paused. We called these respectively “initial,” “studying,” and “paused.” They would help me control which buttons the users would see during a certain state. This would keep the user interface clean and effective. This used a concept called conditional rendering. Conditional rendering is used to display different buttons based on the status of the buttons. If the status is ‘initial,’ then the start and clear buttons are shown. If the status is different, then different buttons may show up. At the same time, we realized that it would technically be possible for the timer to reach 24 hours and then nothing would happen. Given that it is incredibly unhealthy to study for 24 hours straight, we decided that as a productivity app, we would not support this. We thus decided to control this and if the clock hits 24 hours (86400 seconds), then we would automatically clear the timer and pop up an error message on the screen. We took advantage of an element of react called ‘alert’ to display this message. Finally, we had to control for memory leakages. We cleared the interval on the unmount which prevents memory leaks by ensuring that the timer stops when the timer is removed from the DOM (document object model). 


To create the other timer (pomodoro and timer) elements, we adapted the stopwatch code. In researching how to make a timer, we referenced three specific websites: https://blog.greenroots.info/how-to-create-a-countdown-timer-using-react-hooks, https://dev.to/yuridevat/how-to-create-a-timer-with-react-7b9, and https://stackoverflow.com/questions/40885923/countdown-timer-in-react for reference. However, none of these websites had completely the idea which we had in mind. Therefore, we used them as reference but worked on creating my own. The interval works similarly to the stopwatch however in the opposite direction. The input of hours, minutes, and seconds gets converted to total time (in seconds) which then decreases every second. Pause or resume timer works similarly to the stopwatch, but was slightly modified for a cleaner usage. Formatting time was similar to stopwatch. An addition to the code was the use of onChange, which is an event handler that updates the field when the user types in a number. Once it sets the hours, minutes, and seconds to an hour, once the start button is clicked and a time is assigned, the box will change to the timer which will start down. Conditional rendering is used here again. 
The pomodoro timer was a modification of the timer. However, this required the addition of a new mode for the timer (which effectively works as a state). After 4 countdowns on the timer, we could then switch to the second break. We used a division (modulus) to do this. If the mode is “work,” then the timer increments count to check whether to transition to first_break or second_break. The second_break is longer. The useEffect hook listens for changes in the timer, interval_name, mode, and counts to clear the interval when a timer reaches zero and update the modes. When displaying the clock, we show a mode: and then capitalize the first letter of mode to make it look better. We then add the buttons and link functions. 
After we created these three timer functions, We created a .tsx file that would bring all of them together into a menu. We used conditional rendering to bring together and link the timers with their names. We could not combine the two conditional renders together because it would interfere with the CSS. We talked to a TF Gabe LeBlanc about this and he recommended that We keep them separate to prevent any errors. It makes more sense anyways in the logic of the code. We could not do anything about this implementation without messing up all of the UI Chakra elements. We then use two functions (get timer and render timer) to respectively get the name of the timer we want to use and then to render it. Using the respective buttons and conditional rendering, we were able to effectively display the three types of timers with a menu button.

And that’s it for Timeblocker!

<3 Timeblocker Boys

